<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta charset="utf-8"/>
	<link href="css/styles.css" rel="stylesheet" />
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
	
	<script src="js-webshim/minified/extras/modernizr-1.7.min.js"></script>
	
	<script src="js-webshim/minified/polyfiller.js"></script>

    <script class="example">
		//load all polyfill features
		$.webshims.polyfill();
		
    </script>
	
	<title>webshims lib - the polyfilling, capability based loading JS libary</title>
	    
</head>

<body class="home">

		<header>
			<hgroup>
				<h1>Webshims Lib.</h1>
				<h2>Polyfill only the uncapable browsers</h2>
			</hgroup>
			<nav>
				
			</nav>
		</header>
		<div class="main">
			<section>
				<div class="home-box about-box">
					<p>Webshims Lib is a DOM-Extension helper, which enables / polyfills some of the latest browserfeatures often called "HTML5-features" or better <a href="http://www.brucelawson.co.uk/2010/meet-newt-new-exciting-web-technologies/">NEWT</a> in non capable browsers. It is build on Top of <a href="http://jquery.com/">jQuery 1.5.1+</a> and <a href="http://www.modernizr.com/">Modernizr 1.7+</a>.</p>
				</div>
				<div class="home-box download-box">
					<p>
						<a href="http://github.com/aFarkas/webshim/downloads" class="download-button">
							<strong>Download Webshims Lib</strong>
							<span>polyfilling Libary version 1.5.2</span>
						</a>
					</p>
				</div>
				<div class="home-box concept-box">
				<h3>Main concepts</h3>
					<ul>
						<li><strong>Capability based loading:</strong> lightweight for good browsers / heavyweight for really bad browsers</li>
						<li><strong>almost pure native and accurate APIs | no/less abstractions:</strong> Helps you to learn HTML5 (Markup-/DOM/JS-APIs) and to build usefull abstractions and extensions on top of the standard. Documentation is the specification (i.e.: <a href="http://dev.w3.org/html5/html-author/">HTML5 W3C Specification</a>)</li>
						<li><strong>futureproof Feature-Detection:</strong> We try to feature detect everything instead of browsersniffing to be more futureproof</li>
						<li><strong>modular feature implementation:</strong> Only load features, that you need for your webapplication.</li>
					</ul>
				</div>
				<div class="feature-example home-box">
					<h3>What makes webshims lib different?</h3>
					<div class="inner-box">
						<p>Did you ever tried to dynamically set or get the placeholder or the value attribute with one of the other placeholder shims?</p>
						<form action="#">
							<input class="text" name="placeholder" id="placeholder" placeholder="change me" />
						</form>
						
						<code>$("#placeholder").attr("placeholder", "<input value="test text" class="text" id="placeholder-text" />");</code> <button>run code</button>
						<div class="hidden-explanation">
							<p>Being able to add/change the placeholder of an input element dynamically, isn't that important. It only shows how webshims lib works. With some little constraints you won't be able to recognize a difference between the shim and the native implementation. In some cases the shim will be more compilant, than the current browser implementations.</p>
							<p>The placeholder polyfill also works with getting and setting the value property (most/all other placeholder-polyfills don't support this properly):</p>
							<ul>
								<li>$("#placeholder").attr('value') / $("#placeholder").val()</li>
								<li>$("#placeholder").attr('value', 'new value') / $("#placeholder").val('new value')</li>
							</ul>
						</div>
					</div>
				</div>
				<div class="home-box supported-browser-box">
					<h3>Supported Browsers</h3>
					<ul>
						<li>IE6+</li>
						<li>Firefox 3.0+</li>
						<li>Safari 4+</li>
						<li>Safari for iOS 4.2</li>
						<li>Chrome 9.0+</li>
						<li>Opera 10.54+</li>
					</ul>
					
				</div>
				
			</section>
			<section class="feature-overview">
				<hgroup>
					<h2>Features / Demos</h2>
				</hgroup>
				<div>
					<article>
						<h3><a href="demos/shiv.html">Semantic Structure: Shiv solution</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/es5.html">ES5/JavaScript 1.8.5</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/json-storage.html">JSON.parse / JSON.stringify &amp; localStorage / sessionStorage</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/geolocation.html">Geolocation</a></h3>
					</article>
					
					
					<article>
						<h3><a href="demos/canvas.html">Canvas</a></h3>
					</article>
					
					<article>
						<h3><a href="demos/webforms.html">HTML5 forms / Webforms 2</a></h3>
					</article>
				</div>	
			</section>
			<section>
				<hgroup>
					<h2>How to</h2>
				</hgroup>
				<div class="accordion">
				<h3 id="quick-install" class="button">Easy &amp; simple Quick install</h3>
				<div class="panel">
<code class="block">
//reference the base script
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;
	
&lt;script&gt;
	//implement all unsupported features
	$.webshims.polyfill();
	//or load only specific features, you need
	//$.webshims.polyfill('forms json-storage');
	
	$(function(){
		//use all implemented API-features on DOM-ready
	});
&lt;/script&gt;		
</code>
				</div>
	
				<h3 id="embed-polyfill" class="button">Embedding and configuring the script</h3>
				<div class="panel">
					<ul>
						<li>Take the 'js-webshim' folder and add it to your project (You will find a minified and a dev-folder there)</li>
						<li>Include the polyfiller.js into your HTML-Page (you can concat/rename this file with your other js. Don't forget to also include <a href="http://jquery.com">jQuery</a> and <a href="http://www.modernizr.com/">Modernizr</a>)</li>
						<li>call the polyfill-method</li>
					</ul>
				
<code class="block">
&lt;script src="js/jquery-1.5.1.js"&gt;&lt;/script&gt;
&lt;script src="js/modernizr.js"&gt;&lt;/script&gt;
&lt;script src="js-webshim/minified/polyfiller.js"&gt;&lt;/script&gt;


&lt;script&gt;
	//load and implement all unsupported features
	$.webshims.polyfill();
&lt;/script&gt;	
</code>
				
						<p>The polyfill-method can also take a white space seperated list of several features.</p>
<code class="block">
//load and implement json-storage and geolocation features, if they aren't supported
$.webshims.polyfill('json-storage geolocation');
</code>					
						<h3>List of features</h3>
						<ul>
							<li><code>json-storage</code></li>
							<li><code>es5</code></li>
							<li><code>geolocation</code></li>
							<li><code>canvas</code></li>
							<li><code>froms</code></li>
							<li><code>forms-ext</code></li>
						</ul>
	
						<p>The polyfill-method can also take a keyword called <code>lightweight</code>, which will load a filesize-/feature balanced profile. The lightweight-profile currently loads all features, except of the <code>forms-ext</code> feature (numerical and date related web form features). The normal HTML5 <code>forms</code> feature - including constraint validation (required, pattern, [type=email]) and datalist/output widgets - is loaded in the <code>lightweight</code> profile.</p>
<code class="block">
//load and implement all unsupported features from the lightweight profile
$.webshims.polyfill('lightweight');
</code>			
						<p>If you have any troubble setting up Webshims lib, set <code>$.webshims.debug</code> to true and open your Console (Don't forget to activate your firebug console):</p>
<code class="block">							
&lt;script&gt;
	$.webshims.debug = true;
	$.webshims.polyfill();
&lt;/script&gt;	
</code>						
				
				</div>
				<h3 id="polyfill-ready" class="button">When is a feature ready to use?</h3>
				<div class="panel">
				<p>Not every feature is ready immediately in all browsers. To get started, if all features are ready, simply use one of jQuery's ready methods, which are delayed, till all features are available.</p>
<code class="block">
$(function(){
	//work with DOM + all implemented features
});

$(doument).ready(function(){
	//work with DOM + all features
});
</code>		
	
			
					<p>If you want to use a feature as soon as possible you can use <code>$.webshims.ready</code> and pass the feature-name[s] and a callback-function:</p>
<code class="block">
$.webshims.ready('geolocation json-storage', function(){
	//work with geolocation, JSON and localStorage
});
</code>	
					<p>Note that this callback function may be called before DOM-Ready. If you want to use a feature after DOM-Ready, simply pass the string 'DOM':</p>
<code class="block">
$.webshims.ready('DOM canvas', function(){
	//work with canvas in the document
});
</code>	
				</div>
				<h3 id="polyfill-options" class="button">Setting feature specific options</h3>
				<div class="panel">
					<p>Some features have additional options, you can configure these with the <code>$.webshims.setOptions</code>-method. <code>setOptions</code>-method should be always and only called before the <code>polyfill</code>-method:</p>
<code class="block">
$.webshims.setOptions('canvas', {
	type: "flash" //use flashcanvas instead of excanvas as polyfill
});
</code>		
				
					<p><code>setOptions</code> can also take an options-parameter only:</p>
<code class="block">
$.webshims.setOptions({
	//configure canvas-shim
	canvas: {
		type: "flash" //use flashcanvas instead of excanvas as polyfill
	},
	//configure forms-shim
	forms: {
		customMessages: true // implement customValidationMessages - attribute
	}
});
</code>	
				</div>
				<h3 id="polyfill-abstractions" class="button">minor Abstractions to DOM-Attributes, DOM-Methods and DOM-Events</h3>
				<div class="panel">
					<p>Due to the fact, that we can not extend accessors of elements in all browsers, we always use jQuery as an extension-wrapper.</p>
					<ul>
						<li>
							<p><strong>Accessing DOM-Properties/Attribut IDLs</strong>: if the feature allows accessing a specific property, always use jQuery's built in <code>$.attr</code>-method:</p>
<code class="block">
//instead of accessing a property directly (i.e.: this.validity) 
//use $.fn.attr 
$(this).attr('validity');
//or $.attr
//$.attr(this, 'validity');
</code>
						</li>
						<li>
							<p><strong>calling a DOM-Method</strong>: If the standard defines a DOM-Method, webshims lib extends this on the DOM-element or the element's prototype and also generates a jQuery-Plugin, which wraps this feature for you:</p>
<code class="block">
//instead of calling a DOM-method directly (i.e.: this.checkValidity() ) 
//you can also use the jQuery-Plugin method 
$(this).checkValidity();
</code>
							<p>If you pass a list of nodes and the method doesn't return anything, the method will be called on each element in this list, otherwise it will be called on the first element.</p>
							<p>Note: While DOM-properties have to be accessed through jQuery's attr method. DOM-methods are also extended on the DOM elements itself, so you can still call them directly:</p>
<code class="block">
//Note: this refers to a DOM-element not a jQuery object
this.checkValidity();
</code>
						</li>
						<li>
							<p><strong>binding to events</strong>: Always use jQuery's <code>bind</code> method to register your event handlers. <code>addEventListener</code> won't work in polyfilled browsers. Most events in the HTML5 specification are so called simple events. Simple events do not bubble. Due to the fact that developers really like event delegation and jQuery can not distinguish between the event phases (capturing/propagation), we use almost event capturing in the native implementation and $.fn.trigger in the shim.</p>
							<p>This means, that some "HTML5 events" go down the DOM-tree in capable browsers and go up the tree in polyfilled browsers. This can create differences, if you are calling <code>event.stopPropagation();</code> or <code>return false;</code> in your event handler. If you only want to prevent the default don't use <code>return false;</code> and use <code>event.preventDefault();</code> instead.</p>
						</li>
						<li>
							<p><strong>manipulation methods</strong>: Always use <code>.htmlWebshim()</code>, <code>.appendWebshim()</code>, <code>.prependWebshim()</code>, <code>.afterWebshim()</code>, <code>.beforeWebshim()</code> and <code>.replaceWithWebshim()</code> to insert new HTML5 content:</p>
<code class="block">
//three different examples
$('form').appendWebshim('&lt;input type="date" /&gt;');
$('#canvas-box').htmlWebshim('&lt;canvas&gt;&lt;/canvas&gt;');
$('datalist#list select').prependWebshim('&lt;option value="new suggestion item" /&gt;');
</code>
						</li>
					</ul>
					</div>
					<h3 id="implement-polyfill" class="button">How to write a new feature implementation?</h3>
					<div class="panel">
						<p>A Pollyfill is always split into at least 2 parts. First the test and loader definition and second the implementation.</p>
		
		<p>Assume, that there is a "magic" new method called magicMethod on the window-object. An implementation would look like this:</p>
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	}
});
// = load magicMethod.js from shim-folder if test returns false
</code>		
		<p>Create a file called magicMethod with your polyfill-code and place it in the shim-folder:</p>	
<code class="block">
window.magicMethod = function(){
	//your polyfill implementation
};
</code>		

		<p>If your implementation has dependencies to other polyfills/modules. You can create a simple dependency by adding a dependencies-property:</p>
		
<code class="block">
$.webshims.addPolyfill('magicMethod', {
	test: function(){
		return ('magicMethod' in window);	
	},
	dependencies: ['es5', 'json-storage']
});
// = load magicMethod.js from shim-folder if test returns false
</code>		
		<p>If you have setup a dependencies, you have to register your implementation code with <code>$.webshims.register</code>:</p>	
<code class="block">
jQuery.webshims.register('magicMethod', function($, webshims, window, document, undefined, options){
	//now you can use es5-feature and json-storage feature	
	window.magicMethod = function(){
		//your polyfill implementation
	};
});
</code>	

		<p>In case of a DOM-Extension, webshims lib comes with some usefull extension-methods.</p>
<code class="block">
$.webshims.addPolyfill('mediaelement', {
	test: function(){
		return ('canPlayType' in document.createElement('video'));	
	},
	dependencies: ['dom-support'],
	methodNames: ['play'] //pause, load
});
// = load mediaelement.js and DOM-extension features from shim-folder, if test returns false and always create a jQuery-Plugin called play, which trys to invoke native/polyfilled play

//listen to 'play' events in the capturing-phase
//= webdevelopers can use event delegation with jQuery's bind-method
$.webshims.capturingEvents(['play']);
</code>

		<p>Now put a mediaelement.js inside of your shim folder and start implementing some features. The <code>dom-support</code> feature of Webshims lib comes with some very usefull implementation helpers. Here are two of them:</p>
		<ul>
			<li><code>$.webshims.defineNodeNamesProperty</code> (nodeNames, property, descriptor)</li>
			<li><code>$.webshims.defineNodeNamesBooleanProperty</code> (nodeNames, property, descriptor)</li>
		</ul>
<code class="block">
//wait till the DOM-Extension-feature is loaded
jQuery.webshims.register('mediaelement', function($, webshims, window, document, undefined, options){
	
	//Implements a new IDL property on audio, video called currentTime
	$.webshims.defineNodeNamesProperty('audio, video', 'currentTime', {
		get: function(){
			//your getter implementation (this refers to the element)
		},
		set: function(value){
			//your setter implementation (this refers to the element)
		}
	});
	
	//Implements a new constant property called HAVE_CURRENT_DATA on audio, video
	$.webshims.defineNodenamesProperty('audio, video', 'HAVE_CURRENT_DATA', {
		value: 2
	});
	
	//Implements a new method called play on audio, video
	$.webshims.defineNodeNamesProperty('audio, video', 'play', {
		value: function(){
			//your play-method implementation
			//this refers to the element
		}
	});
	
	
	
	//Implements a new boolean IDL property called controls on audio, video
	//which is reflected by a content attribute
	$.webshims.defineNodeNamesBooleanProperty('audio, video', 'controls', {
		//set works more like an onSet:
		//you don't have to set the value anymore on the domnode, only handle true/false values
		set: function(value){
			if(value){
				//show controls for elem
			} else {
				//hide controls for elem
			}
		},
		content: true
	});
});	
</code>
		
					</div>
				</div>
			</section>
			
				
			<section>
				<hgroup>
					<h2>Further Development</h2>
					<h3>Feel free to <a href="https://github.com/aFarkas/webshim">fork</a>, <a href="https://github.com/aFarkas/webshim">collaborate</a>, <a href="https://github.com/aFarkas/webshim/issues">report issues</a>, develope extensions or simply use :-).</h3>
				</hgroup>
				
				<ul>
					<li>improve current implementations</li>
					<li><a href="http://www.w3.org/TR/html5/interactive-elements.html">interactive elements</a> (<strike>we should wait here, till a <a href="https://bugs.webkit.org/show_bug.cgi?id=51071">native implementation</a> exists</strike> comming with 1.6)</li>
					<li><a href="http://www.w3.org/TR/html5/video.html">audio/video</a> implementation (comming in 1.7)</li>
					<li>switching to a third party scriptloader (maybe <a href="https://github.com/SlexAxton/yepnope.js">yepnope</a> (comming in 1.8))</li>
					<li>history (pushState etc.)/hashchange (maybe <a href="https://github.com/balupton/history.js">history.js</a> (comming in 1.9))</li>
				</ul>
				
			</section>
		</div>
		<footer>
			<small>
				<strong>Note</strong>: every polyfill is a hack! innovative frontend development is and will be always hacky!
			</small>
		</footer>
  
	
	
	<script src="demo-js/demo.js"></script>
<!--[if lte IE 7]>
	<div class="browser-support"> 			
		<div class="browser-support-box"> 				
			Webshims Lib really cares about cross browser support and supports all A-Graded Browsers including IE6 and newest Opera. But I don't care about Styling/Layout issues in IE7- on this demo page.
		</div> 		
	</div>
<![endif]-->
</body>
</html>   